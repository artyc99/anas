#include <iostream>

using namespace std;

/*
Структура - пользовательский тип данных, который используется для агрегирования(поэтому зачастую называют агрегирующим типом/классом)
*/

struct person1
{
    int age; // по умолчанию данные параметры структуры являются доступными из вне и к ним можно обращаться
    int height;
};

struct person2
{
    public: // модификатор доступа, который делает поля доступными из вне
    int age;
    int height;

    void print()
    {
        int age;
        int height;
        cout << "age: " << this->age << " height: " << this->height << endl; // this - указатель на сам обьект структуры(используется если есть пересечение имен с структурой)
    };

    void print2(); // вынесли определение метода
    void set_mark(int); // вынесли определение метода установки оценки

    protected: // модификатор доступа, доступно только в структуре и ее потомках(наследуется)
    int score;

    private: // модификатор доступа, доступно только в структуре(не наследуется)
    int mark;
};

void person2::print2(){
    // вне тела структуры, просто потому что могу) а так все стараются придерживаться кода, где модели(структуры данных/агрегатные структуры/агрегатные классы) не содержат определения логики
    int age;
    int height;
    cout << "age: " << this->age << " height: " << this->height << " mark: " << mark << endl; // this - указатель на сам обьект структуры(используется если есть пересечение имен с структурой)
};

void person2::set_mark(int mark){
    this->mark = mark;
    cout << "mark_set: " << this->mark << endl; // this - указатель на сам обьект структуры(используется если есть пересечение имен с структурой)
};

/*
    Также что бы не возникало проблем обычто стараются унифицировать работу с одинаковыми штуками.
    в нашем случае это можно сделать на уровне работы с полями обьекта. Тоесть если мы изменяем что-то в обьекте то используем this. 
    подобного рода договоренности называются конвенциями, их достаточно много и на некоторых работах они могут отличаться ввиду наличия локальных.
*/

/*
Для чего нужны protected и private:
    По факту эти свойства позволяют нам скрывать от других програмистов штуки которые могут нарушать работу нашей логики, поэтому в структурах их определять не принято.
    "Нет ручек нет конфетки :3"
    В своей совокупности это главная их цель.
*/

struct person3:person1 { // person3 наследует публичные и защищенные поля person1... чтобы кода писать меньше)
    const int mark; // добавляем поля к поле person1
    person3(int age, int height, int mark): mark{mark} { // Порядок важно соблюдать так как описано в структуре + {} можно заменить на круглые, также тут происходит магия(то что после двоеточия создася перед созанием обьекта, а то что в методоте в момент существования обьекта. это позволяет задавать значения константам, так как тип const не изменяемый)
        this->age = age;
        this->height = height;
    }; // это конструктор, он собирает обьект так как нам нужно(выделяет память и складывает данные)
    ~person3(){}; // деструктор тут описывается очистка памяти которую выделили итд, само удаление обьекта происходит после выполнения этой функции
};

int main() {
    person1 Bob;
    Bob.age = 10;
    Bob.height = 17;

    cout << "age: " << Bob.age << " height: " << Bob.height << endl;

    person1 Bob1;
    Bob1.age = 100;
    Bob1.height = 1700;

    cout << "age: " << Bob.age << " height: " << Bob.height << endl; // проверка того что у них не общее место для хранения данных и мы изменяет отдельный обьект
    cout << "age: " << Bob1.age << " height: " << Bob1.height << endl; 

    person2 Alice;
    Alice.age = 5;
    Alice.height = 7;

    Alice.print();
    Alice.print2();
    Alice.set_mark(3);
    Alice.print2();

    person3 Kate{3, 150, 5};
    cout << "age: " << Kate.age << " height: " << Kate.height << " mark: " << Kate.mark << endl;
};

/*
Сам по себе конструктор и деструктор создается по дуфолту. тоесть если его не описали то создастся автоматически, таким образом нет структур без данных методов.
Деструктор вызывается в ряде случаев:

когда завершается выполнение области видимости, внутри которой определены объекты

когда удаляется контейнер (например, массив), который содержит объекты

когда удаляется объект, в котором определены переменные, представляющие другие объекты

динамически созданные объекты удаляются при применении к указателю на объект оператора delete
*/

/* 
    как в дальнейшем можно будет заметить особых отличий от классов нет, поскольку структура является пользовательским типом данным и класс так же является пользовательским типом.
    отличие заключается в том что и когда использовать. структуры в общности своей предназначены для хранения данный а не операций над ними(хоть это и возможно делать, но принято разделять логику от данных).
    тоесть в случае хранения данных используются структуры, в случае хранения данных и логики используются классы.
    Тут стоить отметить что структуры ведут себя схоже с классами(p.s. позвояют наследоваться защищать поля и тд. поэтому эта тема будет идти бок о бок с классами).
*/

